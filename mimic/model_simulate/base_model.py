import json
import os
from abc import ABC, abstractmethod

import pandas as pd
import numpy as np


class BaseModel(ABC):
    """
    Abstract base class for a base model.

    Attributes:
        data: The data generated by the model.
        model: The model used for simulation.
        parameters: The parameters of the model.

    Methods:
        check_params: Checks if parameters are set and uses default values if not.
        simulate: Simulates data based on the specified simulation type and parameters.
        read_parameters: Reads parameters from a JSON file.
        save_parameters: Saves parameters to a JSON file.
        print_parameters: Prints parameters to the console.
        save_data: Saves data to a CSV file.
        load_data: Loads data from a CSV file.
    """

    def __init__(self):
        """
        Initialize a new instance of the BaseModel class.
        """
        self.data = None
        self.model = None
        self.parameters = None

    # check if params are set, else print a warning and use the default values for each simulation type

    @abstractmethod
    def set_parameters(self):
        """
        Set parameters for the model.
        This method is implemented in the derived classes.
        """
        pass

    def update_attributes(self):
        """Updates class attributes based on the parameters dictionary."""
        for key, value in self.parameters.items():
            if hasattr(self, key):
                setattr(self, key, value)

    def read_parameters(self, filepath):
        """
        Enhanced to handle numpy arrays alongside native JSON types.
        """
        if not filepath.lower().endswith('.json'):
            raise ValueError("Filepath must point to a .json file.")
        if not os.path.exists(filepath):
            raise FileNotFoundError(f"No file found at {filepath}")

        try:
            with open(filepath, 'r') as file:
                loaded_params = json.load(file)
            # Convert lists back to numpy arrays where appropriate
            self.parameters = {
                k: np.array(v) if isinstance(v, list) else v
                for k, v in loaded_params.items()
            }
            # Update class attributes based on the newly loaded parameters
            self.update_attributes()
        except Exception as e:
            print(f"Error reading parameters from {filepath}: {e}")

    def check_params(self, params, sim_type):
        """
        Check and update simulation parameters.

        Args:
            params (dict): The parameters provided for the simulation.
            sim_type (str): The type of simulation.

        Returns:
            dict: The updated simulation parameters.

        Raises:
            ValueError: If sim_type is not 'VAR' or 'gMLV'.

        Examples:
            >>> params = {"n_obs": 200, "coefficients": [[0.5, -0.5], [0.2, 0.8]], "output": "save"}
            >>> sim_type = "VAR"
            >>> check_params(params, sim_type)
            Using the following parameters for VAR simulation: {'n_obs': 200, 'coefficients': [[0.5, -0.5], [0.2, 0.8]], 'initial_values': [[1], [2]], 'noise_stddev': 1, 'output': 'save'}
        """
        # NOTE: This method is here instead of being implemented by each derived class to avoid code repetition. It is used to check if parameters are set and use default values if not.
        # sourcery skip: use-named-expression
        # Define default parameters for each simulation type
        # FIXME: #46 Change the default parameter generation to whatever dimension the user wants. Right now it's hardcoded to 2.
        default_params_VAR = {"n_obs": 100, "coefficients": [[0.8, -0.2], [0.3, 0.5]],
                              "initial_values": [[1], [2]], "noise_stddev": 1, "output": "show"}
        default_params_gMLV = {"num_species": 2, "num_metabolites": 0,
                               "num_perturbations": 0, "mu": None, "M": None, "beta": None, "epsilon": None}

        # TODO: #48 Do this programmatically (see how the class is initiated and use the same logic to generate the default parameters for the simulation type.)
        default_params_sVAR = {"n_obs": 100, "coefficients": [[0.8, -0.2], [0.3, 0.5]], "initial_values": [[1], [2]], "noise_stddev": 1.0,
                               "output": "show", "coefficientsM": [[0.0, -0.5, 0.0], [0.1, 0.1, -0.1], [-0.2, 0.1, 0.3]], "initial_valuesM": [[2], [0], [0]]}

        # Determine default parameters based on simulation type
        if sim_type == "VAR":
            default_params = default_params_VAR
        elif sim_type == "sVAR":
            default_params = default_params_sVAR
        elif sim_type == "gMLV":
            default_params = default_params_gMLV
        else:
            raise ValueError("sim_type must be 'VAR' or 'gMLV'.")

        # Check if no parameters were provided and warn the user
        if params is None:
            print(
                f"Warning: No parameters provided for {sim_type} simulation. Using default values.")
        else:
            # Identify missing or None parameters
            missing_params = [
                key for key in default_params if key not in params or params[key] is None]
            if missing_params:
                print(
                    f"Warning: Missing or None parameters for {sim_type} simulation. Using default values for: {missing_params}")
            # Update the default parameters with the provided ones
            for key, value in params.items():
                if value is not None:
                    default_params[key] = value

        print(
            f"Using the following parameters for {sim_type} simulation: {default_params}")
        self.parameters = default_params
        self.update_attributes()

    def custom_array_to_string(self, array, precision=2):
        """
        Convert a numpy array to a string with compact formatting.
        Allows specifying the precision of floating-point representations.
        """
        with np.printoptions(precision=precision, suppress=True):
            return np.array2string(array, separator=' ')

    def print_parameters(self, precision=2):
        """
        Print parameters to the console with improved numpy array formatting.
        Allows specifying the precision for numpy array representations.
        """
        print(f"Model: {self.model}")
        if self.parameters is not None:
            parameters = {k: self.custom_array_to_string(v, precision) if isinstance(v, np.ndarray) else v
                          for k, v in self.parameters.items()}
            for param, value in parameters.items():
                print(f"{param}: {value}")
        else:
            print("No parameters to print.")

    def save_parameters(self, filepath, parameters=None):
        """
        Enhanced to handle numpy arrays alongside native JSON types.
        """
        if not filepath.endswith('.json'):
            raise ValueError("Filepath must point to a .json file.")
        if not os.path.exists(os.path.dirname(filepath)) and os.path.dirname(filepath) != '':
            raise FileNotFoundError(
                f"No directory found at {os.path.dirname(filepath)}")

        parameters = parameters if parameters is not None else self.parameters
        if parameters is None:
            print("No parameters to save.")
            return

        # Prepare parameters for JSON serialization
        # Convert numpy arrays to lists
        serializable_params = {
            k: v.tolist() if isinstance(v, np.ndarray) else v
            for k, v in parameters.items()
        }

        try:
            with open(filepath, 'w') as file:
                json.dump(serializable_params, file)
        except Exception as e:
            print(f"Error saving parameters to {filepath}: {e}")

    def save_data(self, filename, data=None):
        """
        Save data to a CSV file.

        Parameters:
        filename (str): The name of the CSV file.
        data (numpy array, optional): The data to save. If None, the instance's data is used.

        Raises:
        ValueError: If `filename` does not end with .csv.
        FileNotFoundError: If the directory to save the file does not exist.
        """
        if not filename.endswith('.csv'):
            raise ValueError("Filename must end with .csv.")
        if not os.path.exists(os.path.dirname(filename)):
            raise FileNotFoundError(
                f"No directory found at {os.path.dirname(filename)}")

        data = data if data is not None else self.data
        if data is None:
            print("No data to save.")
            return

        try:
            pd.DataFrame(data).to_csv(filename, index=False, header=False)
        except Exception as e:
            print(f"Error saving data to {filename}: {e}")
            return False

    def load_data(self, filename):
        """
        Load data from a CSV file.

        Parameters:
        filename (str): The name of the CSV file.

        Raises:
        ValueError: If `filename` does not point to a .csv file.
        FileNotFoundError: If `filename` does not exist.
        """
        if not filename.endswith('.csv'):
            raise ValueError("Filename must point to a .csv file.")
        if not os.path.exists(filename):
            raise FileNotFoundError(f"No file found at {filename}")

        try:
            self.data = pd.read_csv(filename, header=None).values.tolist()
        except Exception as e:
            print(f"Error reading data from {filename}: {e}")
            return False

    @abstractmethod
    def simulate(self):
        """
        Simulate data based on the specified simulation type and parameters.
        This method is implemented in the derived classes.
        """
        pass
